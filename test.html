<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>STT Upload & Record</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        input, button { font-size: 16px; margin-top: 10px; }
        .result { margin-top: 20px; padding: 10px; border: 1px solid #ccc; width: 500px; }
        .label { font-weight: bold; }
    </style>
</head>
<body>
    <h1>STT Upload & Record</h1>

    <h3>Upload file</h3>
    <input type="file" id="audioFile" accept=".wav,.mp3,.m4a">
    <button type="button" onclick="uploadFile()">Upload & Convert</button>

    <h3>Record from Microphone</h3>
    <button type="button" id="recordBtn">Start Recording</button>
    <span id="recordStatus"></span>

    <h3>Real-time Streaming STT</h3>
    <button type="button" id="streamBtn">üé§ Start Streaming</button>
    <span id="streamStatus"></span>
    <div class="result" id="streamResult" style="display:none;">
        <p><span class="label">ƒêang n√≥i (partial):</span></p>
        <p id="partialText" style="color: #666; font-style: italic;"></p>
        <p><span class="label">Full Text:</span></p>
        <p id="streamText" style="font-size: 18px; color: #333;"></p>
    </div>

    <div class="result" id="result" style="display:none;">
        <p><span class="label">File name:</span> <span id="filename"></span></p>
        <p><span class="label">File size:</span> <span id="filesize"></span> bytes</p>
        <p><span class="label">Duration:</span> <span id="duration"></span> s</p>
        <p><span class="label">Language:</span> <span id="language"></span></p>
        <p><span class="label">Text:</span></p>
        <p id="text"></p>
    </div>

    <script>
        async function uploadFile() {
            const fileInput = document.getElementById("audioFile");
            if (!fileInput.files.length) {
                alert("Vui l√≤ng ch·ªçn file audio!");
                return;
            }
            const file = fileInput.files[0];
            sendAudioToServer(file);
        }
        let mediaRecorder;
        let audioChunks = [];

        const recordBtn = document.getElementById("recordBtn");
        const recordStatus = document.getElementById("recordStatus");

        recordBtn.onclick = async () => {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
                recordBtn.innerText = "Start Recording";
            } else {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
                    sendAudioToServer(audioBlob, "recorded_audio.wav");
                    recordStatus.innerText = "";
                };

                mediaRecorder.start();
                recordBtn.innerText = "Stop Recording";
                recordStatus.innerText = "Recording...";
            }
        };

        // Streaming STT
        let ws;
        let streamRecorder;
        let audioStream;
        let audioContext;
        let processor;

        const streamBtn = document.getElementById("streamBtn");
        const streamStatus = document.getElementById("streamStatus");
        const streamResult = document.getElementById("streamResult");
        const streamText = document.getElementById("streamText");
        const partialText = document.getElementById("partialText");

        streamBtn.onclick = async () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (processor) processor.disconnect();
                if (audioContext) audioContext.close();
                if (audioStream) audioStream.getTracks().forEach(track => track.stop());
                ws.close();
                
                streamBtn.innerText = "üé§ Start Streaming";
                streamStatus.innerText = "";
                return;
            }
            
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                ws = new WebSocket("ws://localhost:8000/ws/stt");

                ws.onopen = () => {
                    const TARGET_RATE = 16000;
                    const CHUNK_SEC = 0.05;  
                    const CHUNK_SAMPLES = TARGET_RATE * CHUNK_SEC;

                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: TARGET_RATE });
                    const source = audioContext.createMediaStreamSource(audioStream);
                    processor = audioContext.createScriptProcessor(4096, 1, 1);

                    let pending = new Float32Array(0);

                    function concatFloat32(a, b) {
                        const c = new Float32Array(a.length + b.length);
                        c.set(a, 0);
                        c.set(b, a.length);
                        return c;
                    }

                    function downsampleBuffer(buffer, sampleRate, outRate) {
                        if (outRate === sampleRate) return buffer;
                        const sampleRateRatio = sampleRate / outRate;
                        const newLength = Math.round(buffer.length / sampleRateRatio);
                        const result = new Float32Array(newLength);
                        let offsetResult = 0;
                        let offsetBuffer = 0;
                        while (offsetResult < newLength) {
                            const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                            let accum = 0, count = 0;
                            for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                                accum += buffer[i];
                                count++;
                            }
                            result[offsetResult] = count ? accum / count : 0;
                            offsetResult++;
                            offsetBuffer = nextOffsetBuffer;
                        }
                        return result;
                    }

                    function floatTo16BitPCM(float32Array) {
                        const buffer = new ArrayBuffer(float32Array.length * 2);
                        const view = new DataView(buffer);
                        for (let i = 0; i < float32Array.length; i++) {
                            let s = Math.max(-1, Math.min(1, float32Array[i]));
                            view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                        }
                        return buffer;
                    }

                    processor.onaudioprocess = (e) => {
                        if (ws.readyState !== WebSocket.OPEN) return;
                        const input = e.inputBuffer.getChannelData(0);
                        const down = downsampleBuffer(input, audioContext.sampleRate, TARGET_RATE);
                        pending = concatFloat32(pending, down);

                        while (pending.length >= CHUNK_SAMPLES) {
                            const chunk = pending.subarray(0, CHUNK_SAMPLES);
                            pending = pending.subarray(CHUNK_SAMPLES);
                            const int16buf = floatTo16BitPCM(chunk);
                            ws.send(int16buf);
                        }
                    };

                    const zeroGain = audioContext.createGain();
                    zeroGain.gain.value = 0;

                    source.connect(processor);
                    processor.connect(zeroGain);
                    zeroGain.connect(audioContext.destination);

                    streamBtn.innerText = "D·ª´ng";
                    streamStatus.innerText = "~~";
                    streamResult.style.display = "block";
                    partialText.innerText = "";
                    streamText.innerText = "";
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.status === "listening") {
                        streamStatus.innerText = `ƒêang nghe... (${data.buffer_duration}s)`;
                    } else if (data.partial) {
                        
                        partialText.innerText = "->" + data.partial;
                    }
                    
                    if (data.text) {
                        // Hi·ªÉn th·ªã full text t√≠ch l≈©y
                        streamText.innerText = data.text;
                        
                        if (data.is_final) {
                            partialText.innerText = "";
                            streamStatus.innerText = "ƒêang nghe...";
                        }
                    }
                    
                    if (data.error) {
                        streamStatus.innerText = "L·ªói: " + data.error;
                    }
                };

                ws.onclose = () => {
                    streamBtn.innerText = "üé§ Start Streaming";
                    streamStatus.innerText = "ƒê√£ ng·∫Øt k·∫øt n·ªëi";
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                    }
                };

                ws.onerror = (error) => {
                    streamStatus.innerText = "L·ªói k·∫øt n·ªëi WebSocket";
                    console.error("WebSocket error:", error);
                };
            } catch (err) {
                streamStatus.innerText = "Kh√¥ng th·ªÉ truy c·∫≠p microphone";
                console.error("Mic error:", err);
            }
        };

        async function sendAudioToServer(file, filename=null) {
            const formData = new FormData();
            formData.append("file", file, filename || file.name);

            const resultDiv = document.getElementById("result");
            resultDiv.style.display = "block";
            document.getElementById("text").innerText = "ƒêang x·ª≠ l√Ω...";

            try {
                const response = await fetch("http://127.0.0.1:8000/v1/stt", {
                    method: "POST",
                    body: formData
                });
                const data = await response.json();

                if (data.status === "success" || data.status === "queued") {
                    document.getElementById("filename").innerText = data.filename || "-";
                    document.getElementById("filesize").innerText = data.size_bytes ?? "-";
                    document.getElementById("duration").innerText = data.duration ? data.duration.toFixed(2) : "-";
                    document.getElementById("language").innerText = data.language || "unknown";
                    document.getElementById("text").innerText = data.text || "Ch·ªù x·ª≠ l√Ω...";
                } else {
                    document.getElementById("text").innerText = "L·ªói: " + (data.message || "File d√†i qu√° 30s ");
                }
            } catch (err) {
                document.getElementById("text").innerText = "l·ªói r";
                console.error(err);
            }
        }
    </script>
</body>
</html>
